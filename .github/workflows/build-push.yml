name: Build and Push Docker Image
on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
    paths:
      - 'src/**'
  workflow_dispatch:

env:
  IMAGE_NAME: gh-runner
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  PLATFORMS: linux/amd64,linux/arm64
  MAX_BUILD_NUMBER: 999999
  MAX_VERSION_COMPONENTS: 8
  MAX_FILE_SIZE: 1048576

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update version
        id: version
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit on any error
          
          # Get branch name and clean it
          BRANCH=$(echo ${GITHUB_REF#refs/heads/})
          echo "Current branch: ${BRANCH}"
          
          # Extract version parts and suffix with enhanced validation
          if [[ $BRANCH =~ ^([vV])([0-9]+(\.[0-9]+)*)([-][a-zA-Z0-9._-]+)?$ ]]; then
            VERSION_NUMS="${BASH_REMATCH[2]}"
            SUFFIX="${BASH_REMATCH[4]:-}"
            
            # Normalize version numbers (remove leading zeros)
            VERSION_NUMS=$(echo "$VERSION_NUMS" | sed 's/\b0\+\([0-9]\)/\1/g')
            VERSION_PART="v${VERSION_NUMS}"
            echo "Version part: ${VERSION_PART}"
            echo "Suffix: ${SUFFIX}"
          else
            echo "Branch name doesn't match expected pattern"
            VERSION_PART="v0.0"
            SUFFIX=""
          fi
          
          # Create versions directory if it doesn't exist
          mkdir -p versions
          
          # Clean up other version files
          rm -f versions/*.json
          
          VERSION_FILE="versions/${BRANCH}.json"
          echo "Version file: ${VERSION_FILE}"
          
          # Check if version file exists and get content
          RESPONSE=$(curl -s -w "%{http_code}" -H "Authorization: token ${GH_TOKEN}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${VERSION_FILE}")
          
          HTTP_CODE=${RESPONSE: -3}
          RESPONSE_BODY=${RESPONSE:0:${#RESPONSE}-3}
          
          # Initialize build number
          if [ $HTTP_CODE -eq 200 ] && echo "$RESPONSE_BODY" | jq -e '.content' > /dev/null 2>&1; then
            echo "Existing version file found"
            echo "$RESPONSE_BODY" | jq -r '.content' | base64 --decode > ${VERSION_FILE}
            BUILD_NUMBER=$(jq -r '.build_number' ${VERSION_FILE})
            SHA=$(echo "$RESPONSE_BODY" | jq -r '.sha')
            echo "Current build number: ${BUILD_NUMBER}"
          else
            echo "No existing version file, starting from 0"
            BUILD_NUMBER=0
            SHA=""
          fi
          
          # Increment build number
          NEW_BUILD_NUMBER=$((BUILD_NUMBER + 1))
          if [ $NEW_BUILD_NUMBER -gt $MAX_BUILD_NUMBER ]; then
            echo "Warning: Build number exceeded limit, resetting to 1"
            NEW_BUILD_NUMBER=1
          fi
          echo "New build number: ${NEW_BUILD_NUMBER}"
          
          # Create full version string
          if [ -n "$SUFFIX" ]; then
            FULL_VERSION="${VERSION_PART}.${NEW_BUILD_NUMBER}${SUFFIX}"
          else
            FULL_VERSION="${VERSION_PART}.${NEW_BUILD_NUMBER}"
          fi
          echo "Full version: ${FULL_VERSION}"
          
          # Generate tags array
          declare -a TAGS
          
          # Split version into parts
          IFS='.' read -ra VERSION_PARTS <<< "${VERSION_NUMS}"
          echo "Version parts: ${VERSION_PARTS[@]}"
          
          # Build up version tags
          CURRENT_VERSION="v"
          CURRENT_PARTS=""
          
          for PART in "${VERSION_PARTS[@]}"; do
            CURRENT_PARTS="${CURRENT_PARTS}${PART}"
            TAG_VERSION="v${CURRENT_PARTS}"
            
            if [ -n "$SUFFIX" ]; then
              TAGS+=("${TAG_VERSION}${SUFFIX}")
              echo "Added tag with suffix: ${TAG_VERSION}${SUFFIX}"
            else
              TAGS+=("${TAG_VERSION}")
              echo "Added tag: ${TAG_VERSION}"
            fi
            
            CURRENT_PARTS="${CURRENT_PARTS}."
          done
          
          # Add full version tag
          TAGS+=("${FULL_VERSION}")
          echo "Added full version tag: ${FULL_VERSION}"
          
          # Add suffix-only tag or latest tag
          if [ -n "$SUFFIX" ]; then
            SUFFIX_ONLY="${SUFFIX#-}"
            TAGS+=("${SUFFIX_ONLY}")
            echo "Added suffix tag: ${SUFFIX_ONLY}"
          else
            TAGS+=("latest")
            echo "Added latest tag"
          fi
          
          # Debug: Show all tags
          echo "All tags: ${TAGS[@]}"
          
          # Convert tags array to JSON
          JSON_TAGS=$(printf '%s\n' "${TAGS[@]}" | jq -R . | jq -s .)
          echo "Tags JSON: $JSON_TAGS"
          
          # Create version file content
          VERSION_JSON=$(jq -n \
            --arg branch "$BRANCH" \
            --arg version "$FULL_VERSION" \
            --argjson build_number "$NEW_BUILD_NUMBER" \
            --argjson tags "$JSON_TAGS" \
            '{
              branch: $branch,
              build_number: $build_number,
              version: $version,
              tags: $tags
            }')
          
          echo "$VERSION_JSON" > "${VERSION_FILE}"
          
          # Encode content to base64
          CONTENT=$(base64 -w 0 ${VERSION_FILE})
          
          # Prepare API request body
          if [ -n "$SHA" ]; then
            DATA="{\"message\": \"Update version to ${FULL_VERSION}\", \"content\": \"${CONTENT}\", \"sha\": \"${SHA}\"}"
          else
            DATA="{\"message\": \"Update version to ${FULL_VERSION}\", \"content\": \"${CONTENT}\"}"
          fi
          
          # Update file via GitHub API
          UPLOAD_RESPONSE=$(curl -s -w "%{http_code}" -X PUT -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d "${DATA}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${VERSION_FILE}")
          
          HTTP_CODE=${UPLOAD_RESPONSE: -3}
          RESPONSE_BODY=${UPLOAD_RESPONSE:0:${#UPLOAD_RESPONSE}-3}
          
          if [ $HTTP_CODE -eq 200 ] || [ $HTTP_CODE -eq 201 ]; then
            echo "Version file updated successfully"
          else
            echo "Error: Failed to update version file. Status: $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          
          # Set outputs
          echo "full_version=${FULL_VERSION}" >> $GITHUB_OUTPUT
          echo "tags=${JSON_TAGS}" >> $GITHUB_OUTPUT

      # ... rest of the workflow remains the same ...

      # - name: Set up QEMU
      #   uses: docker/setup-qemu-action@v3

      # - name: Set up Docker Buildx
      #   uses: docker/setup-buildx-action@v3

      # - name: Log in to Docker Hub
      #   if: github.event_name != 'pull_request'
      #   uses: docker/login-action@v3
      #   with:
      #     username: ${{ secrets.DOCKER_USERNAME }}
      #     password: ${{ secrets.DOCKER_TOKEN }}

      # - name: Log in to GitHub Container Registry
      #   if: github.event_name != 'pull_request'
      #   uses: docker/login-action@v3
      #   with:
      #     registry: ghcr.io
      #     username: ${{ github.actor }}
      #     password: ${{ secrets.GITHUB_TOKEN }}

      # - name: Extract metadata (tags, labels) for Docker
      #   id: meta
      #   uses: docker/metadata-action@v5
      #   with:
      #     images: |
      #       ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
      #       ghcr.io/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
      #     tags: ${{ steps.version.outputs.tags }}

      # - name: Build and push Docker image
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: src
      #     platforms: ${{ env.PLATFORMS }}
      #     push: ${{ github.event_name != 'pull_request' }}
      #     tags: ${{ steps.meta.outputs.tags }}
      #     labels: ${{ steps.meta.outputs.labels }}
      #     cache-from: type=gha
      #     cache-to: type=gha,mode=max